/******************************************************************************
     * File: exam_preparation.cpp
     * Description: Универсальный шаблон для создания просейших программ с
       помощью OpenGL.
     * Created: 05.01.2019
     * Copyright: (C) 2019 Top Secret Lab
     * Author: P.Gibshman
******************************************************************************/
#include <GL/glaux.h>  //  функции, создающие простые трёхмерные геометрические объекты, функции, загружающие изображения из\
                            файлов, функции, работающие с окном вывода графики и т.д.
#include <GL/gl.h>  // минимальный/стандартный набор функций для работы OpenGL
#include <GL/glu.h>  // функции работы с матрицами, координатными системами, кривыми и поверхностями NURBS (кривые Безье)
#include <GL/glut.h>  // простая реализация оконного интерфейса

// Переменные
GLfloat dx_rot, dy_rot;
GLfloat ox_rot, oy_rot;

// Массив вершин отрисовываемых объектов
static GLfloat vert[] = {
    /*
    1 - 5, 10, -5,
    2 - 5, 10, -10,
    3 - 10, 10, -10,
    4 - 10, 10, -5,
    5 - 5, 5, -5,
    6 - 5, 5, -10,
    7 - 10, 5, -10,
    8 - 10, 5, -5,
    */

    /// House
    -3, 3, 3,  // верхняя грань
    -3, 3, -3,
    3, 3, -3,
    3, 3, 3,

    -3, 3, 3,  // левая грань
    -3, 3, -3,
    -3, -3, -3,
    -3, -3, 3,

    -3, 3, -3,  // задняя грань
    3, 3, -3,
    3, -3, -3,
    -3, -3, -3,

    3, 3, -3,  // правая грань
    3, 3, 3,
    3, -3, 3,
    3, -3, -3,

    -3, 3, 3,  // передняя грань
    3, 3, 3,
    3, -3, 3,
    -3, -3, 3,

    -3, -3, 3,  // нижняя грань
    -3, -3, -3,
    3, -3, -3,
    3, -3, 3
};

static GLubyte colors[] = {
    123, 160, 91,
    123, 160, 91,
    123, 160, 91,
    123, 160, 91,

    39, 189, 219,
    39, 189, 219,
    39, 189, 219,
    39, 189, 219,

    94, 67, 49,
    94, 67, 49,
    94, 67, 49,
    94, 67, 49,

    94, 189, 49,
    94, 189, 49,
    94, 189, 49,
    94, 189, 49,

    39, 189, 54,
    39, 189, 54,
    39, 189, 54,
    39, 189, 54,

    39, 10, 219,
    39, 10, 219,
    39, 10, 219,
    39, 10, 219
};

// Функция перерисовки окна
void draw () {
    // Очистка буфера. При отсутствии очистки буфера цвета - картинка смазанная, буфера глубины - ничего не отрисовывается и т.д.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /** Возможные параметры glClear()
    * GL_COLOR_BUFFER_BIT	Очистка буфера цвета
    * GL_DEPTH_BUFFER_BIT	Очистка буфера глубины
    * GL_ACCUM_BUFFER_BIT	Очистка буфера накопления
    * GL_STENCIL_BUFFER_BIT	Очистка буфера трафарета
    */
    // Перемещение камеры и вращение кубика
    glLoadIdentity();
    glTranslatef (0, 0, -10);
    glRotatef((ox_rot), 0, 1, 0);
    glRotatef((oy_rot), 1, 0, 0);
    /// Отрисовка домика
    // Мы будем использовать массивs вершин и цветов
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    // Загружаем массив в память
    glVertexPointer(3, GL_FLOAT, 0, vert);
    glColorPointer(3, GL_UNSIGNED_BYTE, 0, colors);
    /* glVertexPointer(GLint size, - указываем сколько значений будут описывать координаты точки, т.е. сколько-мерное пространство
                       GLenum type, - тип данных в котором храниться точка, например GL_SHORT, GL_INT, GL_FLOAT, GL_DOUBLE
                       GLsizei stride, -  смещение до следующующей группы координат. 0 - если данные уложены плотно
                       const GLvoid * pointer - имя массива с данными
                       );
    */
    // Отрисовка
    glDrawArrays(GL_QUADS, 0, 24);

    // Отключене массива
    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_COLOR_ARRAY);
    // Ставит буффер, который мы заполнили, на место активного буффера
    glFlush();
}

// Обработка нажатий клавиш
void key_pressed (unsigned char key, int x, int y){
    switch (key){
    // Обработка вращения куба
    case 'a':
        dx_rot += -0.5;
        break;
    case 'd':
        dx_rot += 0.5;
        break;
    case 'w':
        dy_rot += -0.5;
        break;
    case 's':
        dy_rot += 0.5;
        break;
    default:
        break;
    }
}

// "Итерация" отображения
void redraw () {
    ox_rot+=dx_rot;
    oy_rot+=dy_rot;
    // Вызов перерисовки
    glutPostRedisplay();
    Sleep (25);
    /// Тут происходят изменения, связанные с анимацией
}

// Обработка изменения окна
void change_size(GLsizei w, GLsizei h) {
    // Высота окна не может быть 0
    if (h == 0)
        h = 1;

    // Как воспринимать матричные преобразования, которые будут сейачс происходить
    glMatrixMode(GL_PROJECTION);
    /** glMatrixMode задаёт, к стеку каких матриц будут применяться преобразования. Параметры функции:
    * GL_MODELVIEW  Матрицы для преобразования модели (объекта)
    * GL_PROJECTION Матрицы, используемые для преобразования перспективы или ортогонального преобразования
    * GL_TEXTURE    -"- текстур
    */
    glLoadIdentity();
    // Зааёт перспективу пирамиды (угол обзора, соотношение шириный окна к высоте, минимальная дальность, максимальная дальность)
    gluPerspective(90, (GLdouble)w/h, 1, 300);
    glMatrixMode(GL_MODELVIEW);
    // В какой части окна будет отрисовываться то, что мы задаём
    glViewport(0, 0, (GLdouble)w, (GLdouble)h);

    draw ();
}

// Настройки glut
int init_ogl (int argc, char** argv) {
    glClearColor(1.0f, 0.0f, 0.0f, 1.0f);
    // Инициализация glut
    glutInit(&argc, argv);
    glutInitWindowSize(640, 480);
    glutInitWindowPosition(0, 0);
    // Открытие окна
    glutCreateWindow("Exam preparation");
    // Выбор режима
    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);
    /** Возмржные параметры функции glutInitDisplayMode ()
     * GLUT_RGB     Для отображения графической информации используются 3 компоненты цвета RGB.
     * GLUT_RGBA	То же что и RGB, но используется также 4 компонента ALPHA (прозрачность).
     * GLUT_INDEX	Цвет задается не с помощью RGB компонентов, а с помощью палитры. Используется для старых дисплеев,
                    где количество цветов например 256.
     * GLUT_SINGLE	Вывод в окно осуществляется с использованием 1 буфера. Обычно используется для статического вывода
                    информации.
     * GLUT_DOUBLE	Вывод в окно осуществляется с использованием 2 буферов. Применяется для анимации, чтобы исключить
                    эффект мерцания.
     * GLUT_ACCUM	Использовать также буфер накопления (Accumulation Buffer). Этот буфер применяется для создания специальных
                    эффектов, например отражения и тени.
     * GLUT_ALPHA	Использовать буфер ALPHA. Этот буфер, как уже говорилось используется для задания 4-го компонента цвета - ALPHA.
                    Обычно применяется для таких эффектов как прозрачность объектов и антиалиасинг.
     * GLUT_DEPTH	Создать буфер глубины. Этот буфер используется для отсечения невидимых линий в 3D пространстве при выводе на
                    плоский экран монитора.
     * GLUT_STENCIL	Буфер трафарета используется для таких эффектов как вырезание части фигуры, делая этот кусок прозрачным. Например,
                    наложив прямоугольный трафарет на стену дома, вы получите окно, через которое можно увидеть что находится внутри дома.
     * GLUT_STEREO	Этот флаг используется для создания стереоизображений. Используется редко, так как для просмотра такого изображения
                    нужна специальная аппаратура.
     */
    // Регистрация вызываемых функций
    glutDisplayFunc (draw);
    glutIdleFunc (redraw);
    glutReshapeFunc(change_size);
    /** Функции, связанные с событиями в OpenGL:
     * void glutDisplayFunc(void (*func)(void))
     Функция перерисовки окна.  glutPostRedisplay() вызывает ту функцию, которую передали в glutDisplayFunc() в качестве параметра
     * void glutReshapeFunc(void (*func)(int width, int height))
     Вызывается при изменении размеров окна. int width, int height - новые размеры.
     * void glutVisibilityFunc(void (*func)(int state))
     Окно становиться видимым или невидимым. Чтобы понять, что произошло, параметр state надо сравнить с GLUT_NOT_VISIBLE и GLUT_VISIBLE
     * void glutIdleFunc(void (*func)(void))
     Вызывается, когда приложение простаивает. Часто используют для анимации
     * void glutTimerFunc(unsigned int millis, void (*func)(int value), int value)
     Реализация таймера. value используется для идентификации таймера, если их несколько
    */
    /* Обработка нажалий клавиш - void glutKeyboardFunc(void (*func) (unsigned char key, int x, int y)). x и y - позиция курсора на экране,\
    key - код нажатой клавиши в кодировке ASCII */
    glutKeyboardFunc(key_pressed);
    // Тест глубины, чтобы задние грани рисовались сзади, а не поверх передних
    glEnable(GL_DEPTH_TEST);
    return 0;
}

int main (int argc, char** argv) {
    // Инициализаия OpenGL
    init_ogl (argc, argv);
    glutMainLoop();
    return 0;
}
